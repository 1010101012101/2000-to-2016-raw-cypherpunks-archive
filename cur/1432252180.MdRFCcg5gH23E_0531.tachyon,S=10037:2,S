From rswatjfet.org+caf_=rsw=jfet.org@gmail.com  Fri Feb 20 05:30:46 2015
Return-Path: <rswatjfet.org+caf_=rsw=jfet.org@gmail.com>
Received: from mail-pa0-f44.google.com (mail-pa0-f44.google.com [209.85.220.44])
	by antiproton.jfet.org (8.14.4/8.14.4/Debian-4.1) with ESMTP id t1KAUiNE015628
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NOT)
	for <rsw@jfet.org>; Fri, 20 Feb 2015 05:30:45 -0500
Received: by paceu11 with SMTP id eu11so7075449pac.7
        for <rsw@jfet.org>; Fri, 20 Feb 2015 02:30:38 -0800 (PST)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20130820;
        h=x-original-authentication-results:delivered-to:date:to:subject
         :message-id:mime-version:content-type:content-disposition:user-agent
         :precedence:list-id:list-unsubscribe:list-archive:list-post
         :list-help:list-subscribe:errors-to:sender:from;
        bh=/Wp8a05D2MixR9DNDjBFgAWnR6iSYKN8s13xDL+Kt2w=;
        b=dkGgb8XuOigdo9mR5fwF9lL4yNoJYDSfE9kewwYEwt66Q67XT26yTnoFsKK21rrRsO
         ARIgVycKO8W4J407+zbpN5fvV6eEen84fs+AQBTzpzRMGM1yVkJXfdcH47sa0f6tiyNq
         kPsSC1Drp/gR61IDQG2pqRySt7gdMiFatSe4IqKfJX3Nm6lhda8+6Htvav2Tqm++0lmB
         vMmaxtqY4ui9QBtNfuwXgw5xJPUWiTkQT42PkXdJBTmEsOuzB64Wp5sNH6VOf3U8JQ9p
         7HQH8uiAUcd/hrkCUDLJxZLWCw5wqsZcvdUkuV6Hek7MTKnodRT2R4tcvfQPjs6KqDDh
         mGfw==
X-Original-Authentication-Results: mx.google.com;       spf=neutral (google.com: 209.141.47.85 is neither permitted nor denied by domain of rsw+cypherpunks-bounces=cpunks.org@gloop.phonon.net) smtp.mail=rsw+cypherpunks-bounces=cpunks.org@gloop.phonon.net
X-Received: by 10.70.3.100 with SMTP id b4mr15705768pdb.148.1424428238496;
        Fri, 20 Feb 2015 02:30:38 -0800 (PST)
X-Forwarded-To: rsw@jfet.org
X-Forwarded-For: rswatjfet.org@gmail.com rsw@jfet.org
Delivered-To: rswatjfet.org@gmail.com
Received: by 10.70.127.72 with SMTP id ne8csp1005694pdb;
        Fri, 20 Feb 2015 02:30:37 -0800 (PST)
X-Received: by 10.68.203.166 with SMTP id kr6mr15900503pbc.92.1424428237315;
        Fri, 20 Feb 2015 02:30:37 -0800 (PST)
Received: from localhost (antiproton.jfet.org. [209.141.47.85])
        by mx.google.com with ESMTPS id fk16si10526971pac.105.2015.02.20.02.30.36
        for <rswATjfet.org@gmail.com>
        (version=TLSv1.2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
        Fri, 20 Feb 2015 02:30:36 -0800 (PST)
Received-SPF: neutral (google.com: 209.141.47.85 is neither permitted nor denied by domain of rsw+cypherpunks-bounces=cpunks.org@gloop.phonon.net) client-ip=209.141.47.85;
Authentication-Results: mx.google.com;
       spf=neutral (google.com: 209.141.47.85 is neither permitted nor denied by domain of rsw+cypherpunks-bounces=cpunks.org@gloop.phonon.net) smtp.mail=rsw+cypherpunks-bounces=cpunks.org@gloop.phonon.net
Received: from antiproton.jfet.org (localhost.localdomain [127.0.0.1])
	by antiproton.jfet.org (8.14.4/8.14.4/Debian-4.1) with ESMTP id t1KATRqP015593;
	Fri, 20 Feb 2015 05:29:32 -0500
Received: from x1.ctrlc.hu (x1.ctrlc.hu [195.14.20.232])
 by antiproton.jfet.org (8.14.4/8.14.4/Debian-4.1) with ESMTP id t1KATJwM015589
 for <cypherpunks@cpunks.org>; Fri, 20 Feb 2015 05:29:21 -0500
Received: from i.ctrlc.hu (unknown
 [IPv6:fc8c:1767:11aa:2214:2767:6acb:77ab:a45d])
 by x1.ctrlc.hu (Postfix) with ESMTP id 6F18235CA3
 for <cypherpunks@cpunks.org>; Fri, 20 Feb 2015 11:29:16 +0100 (CET)
Received: by i.ctrlc.hu (Postfix, from userid 1000)
 id 0673115C9F; Fri, 20 Feb 2015 11:30:21 +0100 (CET)
Date: Fri, 20 Feb 2015 11:30:21 +0100
To: cypherpunks <cypherpunks@cpunks.org>
Subject: writing code and mails at the same time! woohooo - one-way encryption
Message-ID: <20150220103021.GA6813@ctrlc.hu>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.5.23 (2014-03-12)
X-BeenThere: cypherpunks@cpunks.org
X-Mailman-Version: 2.1.18
Precedence: list
List-Id: The Cypherpunks Mailing List <cypherpunks.cpunks.org>
List-Unsubscribe: <https://cpunks.org/mailman/options/cypherpunks>,
 <mailto:cypherpunks-request@cpunks.org?subject=unsubscribe>
List-Archive: <http://cpunks.org/pipermail/cypherpunks/>
List-Post: <mailto:cypherpunks@cpunks.org>
List-Help: <mailto:cypherpunks-request@cpunks.org?subject=help>
List-Subscribe: <https://cpunks.org/mailman/listinfo/cypherpunks>,
 <mailto:cypherpunks-request@cpunks.org?subject=subscribe>
Errors-To: cypherpunks-bounces@cpunks.org
Sender: "cypherpunks" <cypherpunks-bounces@cpunks.org>
From: stef <s@ctrlc.hu>
X-Gspam-Loop: antiproton.jfet.org
Status: O
Content-Length: 5440
Lines: 177

apparently on mailing lists it's common to write mails, even cypherpunks do
that instead of code. allow me to combine the two things.

i thought it trough, and figured, that with openssl i have no AD crypto, with
gpg i have this MDC thingy and the rfc4880 strongselector beacon
strongselector, and with nacl and it's key derivation using ecdh make them all
unsuitable on first sight for the use-case.

re my 7 rules, i think i need to work on the threat model to have 100% score

pls enjoy (also as contributions to the copyleft/permissive licensing thread)
and comment:

#!/usr/bin/env python
#
# implements simple one-way encryption pipe using rsa and keccak-based
# spongewrap
#
# useful at least in the following use-case: you have an untrusted
# host on which plaintext data arrives, which you want to encrypt
# before it is forwarded in a hostile environment to the final
# recipient holding a private key in a safe location. In this one-way
# setting the recipient is never talking to the host doing the
# encryption.
#
# Example: take photos in a hostile situation, encrypt the the photos
# and being unable to recover them until arrival in the save location
# with the the private key. (note, this does not protect against
# forensics!)
#
# crypto: a random 32 byte message key is encrypted with the public
# key of the recipient in oaep padded RSA, then this message key is
# fed into SpongeWrap, which is then used to authenticated encrypt the
# message.
#
# output format:
#    2  bytes - the length of the RSA encrypted message key
#    n  bytes - the RSA encrypted message key
#    m  bytes - the encrypted message
#    16 bytes - the "MAC"
#
# depends: `pip install m2crypto spongeshaker SecureString`
#
# create keys using openssl:
# `openssl genrsa -out my.key 4096`
# `openssl rsa -in my.key -pubout >> my.pub`
# `cat my.key my.pub >>my.pem`
# `srm -fll my.key`
#
# deploy my.pub on the encrypting host, secure my.pem in a safe
# location for decryption.
#
# test with:
#
# for i in {0..42} {8170..8210} 1000000; do
#     echo -ne "\r$i   "
#     dd if=/dev/zero bs=$i count=1 2>/dev/null |
#          ./ondir.py e my.pub |
#          ./ondir.py d my.pem >/dev/null ||
#          break
# done
#
# (C) 2015 by Stefan Marsiske, <s@ctrlc.hu>, GPLv3

import M2Crypto as m2c
from spongeshaker.spongewrap import SpongeWrap
from SecureString import clearmem
import sys, struct

TAGLEN = 16
BUFLEN = 8192

def encrypt(to):
    # load recipient pk
    key = m2c.RSA.load_pub_key(to)

    # gen message key
    mkey = m2c.Rand.rand_bytes(32)

    # encrypt message key
    cmkey = key.public_encrypt(mkey, m2c.RSA.pkcs1_oaep_padding)

    # output message key
    sys.stdout.write(struct.pack("H", len(cmkey)))
    sys.stdout.write(cmkey)

    # encrypt message
    ctx = SpongeWrap(1536)
    # with mkey
    ctx.add_header(mkey)
    # mkey not needed anymore
    clearmem(mkey)

    # buffered encrypt of stdin to stdout
    while 1:
        buf = sys.stdin.read(BUFLEN)
        if not buf:
            break
        sys.stdout.write(ctx.encrypt_body(buf))
    # calculate tag
    tag=ctx.digest(TAGLEN)
    # output tag
    sys.stdout.write(tag)

def decrypt(to):
    # load recipient pk
    key = m2c.RSA.load_key(to)

    # read msg key
    klen = struct.unpack('H', sys.stdin.read(2))[0]
    if klen>1024:
        print >>sys.stderr, "probably corrupt file"
        sys.exit(1)
    cmkey = sys.stdin.read(klen)

    # decrypt message key
    try:
        mkey = key.private_decrypt(cmkey, m2c.RSA.pkcs1_oaep_padding)
    except:
        # twarth timing attacks
        mkey = 'couldntdecryptkey'

    # todo clear private RSA key from memory

    # decrypt with mkey
    ctx = SpongeWrap(1536)
    ctx.add_header(mkey)
    # mkey not needed anymore
    clearmem(mkey)

    zero = True # to detect empty files
    rest = ''
    # buffered reading of stdin, since we need to catch the last
    # bytes for the tag, we always retain the last n bytes for
    # this purpose in rest
    while 1:
        buf = sys.stdin.read(BUFLEN)
        if zero and len(buf)>TAGLEN: zero=False
        tag=buf[-TAGLEN:]
        if len(buf)>TAGLEN:
            # prepend the retained last bytes to the next decrypt, if
            # there's enough more bytes read
            sys.stdout.write(ctx.decrypt_body(rest+buf[:-TAGLEN]))
        elif len(buf)>0:
            if len(tag)==TAGLEN:
                # we have exactly the tag read in buf, decrypt the
                # rest
                sys.stdout.write(ctx.decrypt_body(rest))
            else:
                # truncate the last bytes, as we have a boundary
                # spanning tag
                sys.stdout.write(ctx.decrypt_body(rest[:-TAGLEN+len(tag)]))

        if len(buf)<BUFLEN:
            # this is the last buffer
            if len(tag)<TAGLEN:
                # we have a tag spanning a buffer boundary, we must
                # patch it up
                tag = ''.join((rest, buf[:-TAGLEN], tag))[-TAGLEN:]
            # verify if tag is valid
            if not zero and tag!=ctx.digest(TAGLEN):
                print >>sys.stderr, "couldn't decrypt message"
                sys.exit(1)
            break
        rest=tag

if __name__ == '__main__':
    if sys.argv[1]=='e':
        encrypt(sys.argv[2])
    elif sys.argv[1]=='d':
        decrypt(sys.argv[2])
    else:
        print "usage: %s <e|d> <pub|key>"


-- 
otr fp: https://www.ctrlc.hu/~stef/otr.txt

