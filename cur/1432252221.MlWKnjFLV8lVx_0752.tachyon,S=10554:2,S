From rswatjfet.org+caf_=rsw=jfet.org@gmail.com  Tue Jul  8 16:33:16 2014
Return-Path: <rswatjfet.org+caf_=rsw=jfet.org@gmail.com>
Received: from mail-pd0-f176.google.com (mail-pd0-f176.google.com [209.85.192.176])
	by antiproton.jfet.org (8.14.4/8.14.4/Debian-4.1) with ESMTP id s68KXEOf027213
	(version=TLSv1/SSLv3 cipher=RC4-SHA bits=128 verify=NOT)
	for <rsw@jfet.org>; Tue, 8 Jul 2014 16:33:16 -0400
Authentication-Results: antiproton.jfet.org; dkim=fail
	reason="verification failed; unprotected key"
	header.d=gmail.com header.i=@gmail.com header.b=nQEmSebj;
	dkim-adsp=none (unprotected policy); dkim-atps=neutral
Received: by mail-pd0-f176.google.com with SMTP id ft15so7677719pdb.7
        for <rsw@jfet.org>; Tue, 08 Jul 2014 13:33:09 -0700 (PDT)
X-Received: by 10.68.131.230 with SMTP id op6mr37451587pbb.55.1404851588958;
        Tue, 08 Jul 2014 13:33:08 -0700 (PDT)
X-Forwarded-To: rsw@jfet.org
X-Forwarded-For: rswatjfet.org@gmail.com rsw@jfet.org
Delivered-To: rswatjfet.org@gmail.com
Received: by 10.70.25.164 with SMTP id d4csp368098pdg;
        Tue, 8 Jul 2014 13:33:08 -0700 (PDT)
X-Received: by 10.66.228.37 with SMTP id sf5mr37335274pac.19.1404851588115;
        Tue, 08 Jul 2014 13:33:08 -0700 (PDT)
Received: from localhost (antiproton.jfet.org. [209.141.47.85])
        by mx.google.com with ESMTPS id yj9si44301174pab.135.2014.07.08.13.33.07
        for <rswATjfet.org@gmail.com>
        (version=TLSv1.2 cipher=RC4-SHA bits=128/128);
        Tue, 08 Jul 2014 13:33:08 -0700 (PDT)
Received-SPF: neutral (google.com: 209.141.47.85 is neither permitted nor denied by domain of rsw+cypherpunks-bounces=cpunks.org@gloop.phonon.net) client-ip=209.141.47.85;
Authentication-Results: mx.google.com;
       spf=neutral (google.com: 209.141.47.85 is neither permitted nor denied by domain of rsw+cypherpunks-bounces=cpunks.org@gloop.phonon.net) smtp.mail=rsw+cypherpunks-bounces=cpunks.org@gloop.phonon.net;
       dkim=fail header.i=@gmail.com
Received: from antiproton.jfet.org (localhost.localdomain [127.0.0.1])
	by antiproton.jfet.org (8.14.4/8.14.4/Debian-4.1) with ESMTP id s68KVZMN027195;
	Tue, 8 Jul 2014 16:31:42 -0400
Received: from mail-qa0-f47.google.com (mail-qa0-f47.google.com
 [209.85.216.47])
 by antiproton.jfet.org (8.14.4/8.14.4/Debian-4.1) with ESMTP id s68KVXD9027191
 (version=TLSv1/SSLv3 cipher=RC4-SHA bits=128 verify=NOT)
 for <cypherpunks@cpunks.org>; Tue, 8 Jul 2014 16:31:34 -0400
Received: by mail-qa0-f47.google.com with SMTP id i13so70856qae.34
 for <cypherpunks@cpunks.org>; Tue, 08 Jul 2014 13:31:27 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20120113;
 h=mime-version:sender:in-reply-to:references:from:date:message-id
 :subject:to:cc:content-type;
 bh=fr7P01aUbHMb2kZycrtT7yho6wrKm4B4UrMgAbKmfZk=;
 b=nQEmSebjTpRzfKVKxRGxrevAHPBhiC7feuzD7C9nwkq4sMKiM4/EgpIOe2pduwofhh
 7YZ0PiYH1yN3vtEgzQA42/Hj+ahMsdHuYtR9AtS+uyjqnwnzYVGoZ47L8f1fswj/xno1
 u+rX74yk2/o4g3lclrwIuBhv4a/lofWQY6THwuh/0PatWCfgMzy7Vne6z+BYcod66Yrz
 pUNlXN8VcchYEXdY6aFUrrAstcCZ/iMOahX+VfIVPEIPHRwLN6RPRExCgenWBTkiYTTk
 FVx3WONoOhCB9164uUHJYQUIZEipazQhT3Dy0TFeqx2zNavQCEeqzShT5KgXzeS+Y8c1
 eFtg==
X-Received: by 10.140.88.230 with SMTP id t93mr49807564qgd.47.1404851487546;
 Tue, 08 Jul 2014 13:31:27 -0700 (PDT)
MIME-Version: 1.0
Received: by 10.229.164.65 with HTTP; Tue, 8 Jul 2014 13:31:06 -0700 (PDT)
In-Reply-To: <CAOE4rSziWQxm-3W6UP_hCAJN1u3stPbqn-nSXEu7oxcKYjVf_w@mail.gmail.com>
References: <53B84037.7030406@cathalgarvey.me> <20140707084122.GQ6997@ctrlc.hu>
 <CAOE4rSwC55WuYLNRtV5ihZOoVakcaFeV6Z4_a--2nV3d7nOk-g@mail.gmail.com>
 <1997735.1n1TTR1eli@lapuntu> <53BB899A.40408@gmail.com>
 <CAOsGNSS1H87C666NJKNi7SQaftkxZkRhq6JOoS6NwyZsS5vaKg@mail.gmail.com>
 <CAOE4rSzEMCjRo57VQfP2gQ4xrCpKLxKd23XvH0YxH7ZE7jCnmQ@mail.gmail.com>
 <969fa7d4-d6b4-4d5c-bbbf-c5d7b6482746@email.android.com>
 <CAOE4rSziWQxm-3W6UP_hCAJN1u3stPbqn-nSXEu7oxcKYjVf_w@mail.gmail.com>
Date: Tue, 8 Jul 2014 22:31:06 +0200
X-Google-Sender-Auth: YnugFXKvt7fjzs6clQSFvuEg89U
Message-ID: <CAHWD2rL9gJv30n8AsjqF-ngbmu0F61jZRnCLTyX3k4OyoR8m2g@mail.gmail.com>
Subject: Re: Tox.im
To: =?UTF-8?B?RMSBdmlzIE1vc8SBbnM=?= <davispuh@gmail.com>
Content-Type: multipart/alternative; boundary=001a11c13d12e0a43004fdb479dc
Cc: "cypherpunks@cpunks.org" <cypherpunks@cpunks.org>
X-BeenThere: cypherpunks@cpunks.org
X-Mailman-Version: 2.1.16
Precedence: list
List-Id: The Cypherpunks Mailing List <cypherpunks.cpunks.org>
List-Unsubscribe: <https://cpunks.org/mailman/options/cypherpunks>,
 <mailto:cypherpunks-request@cpunks.org?subject=unsubscribe>
List-Archive: <http://cpunks.org/pipermail/cypherpunks/>
List-Post: <mailto:cypherpunks@cpunks.org>
List-Help: <mailto:cypherpunks-request@cpunks.org?subject=help>
List-Subscribe: <https://cpunks.org/mailman/listinfo/cypherpunks>,
 <mailto:cypherpunks-request@cpunks.org?subject=subscribe>
Errors-To: cypherpunks-bounces@cpunks.org
Sender: "cypherpunks" <cypherpunks-bounces@cpunks.org>
From: =?UTF-8?Q?Lodewijk_andr=C3=A9_de_la_porte?= <l@odewijk.nl>
X-Gspam-Loop: antiproton.jfet.org
Status: O
Content-Length: 5464
Lines: 108

--001a11c13d12e0a43004fdb479dc
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

2014-07-08 21:53 GMT+02:00 D=C4=81vis Mos=C4=81ns <davispuh@gmail.com>:

> Also what about NUL bytes? I bet most parsers are implemented in C/C++
> using typical char * null-terminated string, how'll pass this JSON to
> someone? because well NUL...


At the parser level you would find a "b" character that's not between
brackets, signalling a binary header is coming. A binary header is actually
just the number of bytes that follow in binary format. The following bytes
are then a binary file, to be assigned to a string as if it were a
variable. We have a binarybuffer in javascript, that sort of thing. It
would contain the NULL byte if you like it to.

That may break some parsers, but this is the real life. Parsers must deal
with malformed input securely already > being unaware of bencoding2 should
not cause problems.

If the length-indicating thingy is short of what it should binary will
spill over into your JSON document. It may represent perfectly fine JSON,
and thus opens up binary overflow as a possible JSON hack. Someone that can
alter that number can already hack your JSON, so that doesn't actually
change any attack profile.

If it's too long it will gobble up your JSON file, which opens up reading
the rest of the file and maybe even into random memory and treating it as a
file in your JSON. That's much more serious but requires the JSON parser to
have bugs.

The thing is that if you don't cut yourself in the fingers it can be nice
to have a knife. If you don't write some pretty obvious bugs you will be
fine.

I think it's much more serious that you have to serve the BJSON completely
as a binary file. It's not like you can dump it onto a webpage anymore. You
can't slip it into your normal HTTP text transfer bodies either, has to
work with attachments. Attachments should be secure when facing malformed
transfers* etc. Inconvenient, but not the end.

* It would be pretty wack to mess with the HTTP protocol. Maybe you could
confuse a keep-alive connection to serve a file before it should be,
confusing a webapp or sending a redirect. Haven't really looked into it and
haven't really heard about it either. Maybe servers are just secure enough
against those attacks?

--001a11c13d12e0a43004fdb479dc
Content-Type: text/html; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

<div dir=3D"ltr"><div class=3D"gmail_extra"><div class=3D"gmail_quote">2014=
-07-08 21:53 GMT+02:00 D=C4=81vis Mos=C4=81ns <span dir=3D"ltr">&lt;<a href=
=3D"mailto:davispuh@gmail.com" target=3D"_blank">davispuh@gmail.com</a>&gt;=
</span>:<br><blockquote class=3D"gmail_quote" style=3D"margin:0 0 0 .8ex;bo=
rder-left:1px #ccc solid;padding-left:1ex">

 Also what about NUL bytes? I bet most parsers are implemented in C/C++ usi=
ng typical char * null-terminated string, how&#39;ll pass this JSON to some=
one? because well NUL...</blockquote></div><br>At the parser level you woul=
d find a &quot;b&quot; character that&#39;s not between brackets, signallin=
g a binary header is coming. A binary header is actually just the number of=
 bytes that follow in binary format. The following bytes are then a binary =
file, to be assigned to a string as if it were a variable. We have a binary=
buffer in javascript, that sort of thing. It would contain the NULL byte if=
 you like it to.</div>

<div class=3D"gmail_extra"><br>That may break some parsers, but this is the=
 real life. Parsers must deal with malformed input securely already &gt; be=
ing unaware of bencoding2 should not cause problems.</div><div class=3D"gma=
il_extra">

<br></div><div class=3D"gmail_extra">If the length-indicating thingy is sho=
rt of what it should binary will spill over into your JSON document. It may=
 represent perfectly fine JSON, and thus opens up binary overflow as a poss=
ible JSON hack. Someone that can alter that number can already hack your JS=
ON, so that doesn&#39;t actually change any attack profile.=C2=A0</div>

<div class=3D"gmail_extra"><br></div><div class=3D"gmail_extra">If it&#39;s=
 too long it will gobble up your JSON file, which opens up reading the rest=
 of the file and maybe even into random memory and treating it as a file in=
 your JSON. That&#39;s much more serious but requires the JSON parser to ha=
ve bugs.</div>

<div class=3D"gmail_extra"><br></div><div class=3D"gmail_extra">The thing i=
s that if you don&#39;t cut yourself in the fingers it can be nice to have =
a knife. If you don&#39;t write some pretty obvious bugs you will be fine.<=
/div>

<div class=3D"gmail_extra"><br>I think it&#39;s much more serious that you =
have to serve the BJSON completely as a binary file. It&#39;s not like you =
can dump it onto a webpage anymore. You can&#39;t slip it into your normal =
HTTP text transfer bodies either, has to work with attachments. Attachments=
 should be secure when facing malformed transfers* etc. Inconvenient, but n=
ot the end.</div>

<div class=3D"gmail_extra"><br></div><div class=3D"gmail_extra">* It would =
be pretty wack to mess with the HTTP protocol. Maybe you could confuse a ke=
ep-alive connection to serve a file before it should be, confusing a webapp=
 or sending a redirect. Haven&#39;t really looked into it and haven&#39;t r=
eally heard about it either. Maybe servers are just secure enough against t=
hose attacks?</div>

</div>

--001a11c13d12e0a43004fdb479dc--

