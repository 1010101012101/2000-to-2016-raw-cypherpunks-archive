From rswatjfet.org+caf_=rsw=jfet.org@gmail.com  Wed Jul  9 18:32:10 2014
Return-Path: <rswatjfet.org+caf_=rsw=jfet.org@gmail.com>
Received: from mail-pd0-f180.google.com (mail-pd0-f180.google.com [209.85.192.180])
	by antiproton.jfet.org (8.14.4/8.14.4/Debian-4.1) with ESMTP id s69MW9p8004861
	(version=TLSv1/SSLv3 cipher=RC4-SHA bits=128 verify=NOT)
	for <rsw@jfet.org>; Wed, 9 Jul 2014 18:32:10 -0400
Authentication-Results: antiproton.jfet.org; dkim=fail
	reason="verification failed; unprotected key"
	header.d=gmail.com header.i=@gmail.com header.b=ZIsSrA75;
	dkim-adsp=none (unprotected policy); dkim-atps=neutral
Received: by mail-pd0-f180.google.com with SMTP id fp1so9723940pdb.11
        for <rsw@jfet.org>; Wed, 09 Jul 2014 15:32:03 -0700 (PDT)
X-Received: by 10.68.252.41 with SMTP id zp9mr33614190pbc.65.1404945122811;
        Wed, 09 Jul 2014 15:32:02 -0700 (PDT)
X-Forwarded-To: rsw@jfet.org
X-Forwarded-For: rswatjfet.org@gmail.com rsw@jfet.org
Delivered-To: rswatjfet.org@gmail.com
Received: by 10.70.25.164 with SMTP id d4csp446125pdg;
        Wed, 9 Jul 2014 15:32:01 -0700 (PDT)
X-Received: by 10.66.236.161 with SMTP id uv1mr43796118pac.85.1404945121031;
        Wed, 09 Jul 2014 15:32:01 -0700 (PDT)
Received: from localhost (antiproton.jfet.org. [209.141.47.85])
        by mx.google.com with ESMTPS id pn2si47037745pbb.70.2014.07.09.15.32.00
        for <rswATjfet.org@gmail.com>
        (version=TLSv1.2 cipher=RC4-SHA bits=128/128);
        Wed, 09 Jul 2014 15:32:01 -0700 (PDT)
Received-SPF: neutral (google.com: 209.141.47.85 is neither permitted nor denied by domain of rsw+cypherpunks-bounces=cpunks.org@gloop.phonon.net) client-ip=209.141.47.85;
Authentication-Results: mx.google.com;
       spf=neutral (google.com: 209.141.47.85 is neither permitted nor denied by domain of rsw+cypherpunks-bounces=cpunks.org@gloop.phonon.net) smtp.mail=rsw+cypherpunks-bounces=cpunks.org@gloop.phonon.net;
       dkim=fail header.i=@gmail.com;
       dmarc=fail (p=NONE dis=NONE) header.from=gmail.com
Received: from antiproton.jfet.org (localhost.localdomain [127.0.0.1])
	by antiproton.jfet.org (8.14.4/8.14.4/Debian-4.1) with ESMTP id s69MRVqP004839;
	Wed, 9 Jul 2014 18:27:54 -0400
Received: from mail-qg0-f52.google.com (mail-qg0-f52.google.com
 [209.85.192.52])
 by antiproton.jfet.org (8.14.4/8.14.4/Debian-4.1) with ESMTP id s69MRKJ7004834
 (version=TLSv1/SSLv3 cipher=RC4-SHA bits=128 verify=NOT)
 for <cypherpunks@cpunks.org>; Wed, 9 Jul 2014 18:27:22 -0400
Received: by mail-qg0-f52.google.com with SMTP id a108so77541qge.25
 for <cypherpunks@cpunks.org>; Wed, 09 Jul 2014 15:27:14 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20120113;
 h=mime-version:in-reply-to:references:date:message-id:subject:from:to
 :cc:content-type;
 bh=96lNd7PPNsy+vzkjzDWxMlwRAb+ldEnRlGzRtTyywbA=;
 b=ZIsSrA75msiabBJ6r14tE1tY4T+UaNpGI/SVPFrz2YYLj02TlOdOyZaxIOVnqM1RTL
 JzKHNY29gZuTDBXTWCEhdyZ3NbNHOeOkoezCy46xNMHIxM8MIu23QzE/RIt3qApKHhZ/
 dU9pt+H6X8dXIxZNDxuxM4XOc3Hiz8VEPSt4X0jbDPeWATCLpbMxPpgs6KTEsjbnAEfY
 Iynp7+B6HCKOFhNW8CJmQT6IUGTUrGfpeqhigPOQ+0czk1mxJptH+2GurpCeuOMHtyGj
 Bntxe2I9KgZcjZ2J0BDiCcxF7LkkHjO0M5pyUvUlYrB59GypwgwDioRgz4+z9mukFtHl
 U8Jw==
MIME-Version: 1.0
X-Received: by 10.224.49.71 with SMTP id u7mr74981367qaf.58.1404944834588;
 Wed, 09 Jul 2014 15:27:14 -0700 (PDT)
Received: by 10.229.11.197 with HTTP; Wed, 9 Jul 2014 15:27:14 -0700 (PDT)
In-Reply-To: <CAHWD2rJt55_FiCNruwkoJ-_YKav9H+PSdhEjM8D7rTpzko4YDQ@mail.gmail.com>
References: <53B84037.7030406@cathalgarvey.me> <20140707084122.GQ6997@ctrlc.hu>
 <CAOE4rSwC55WuYLNRtV5ihZOoVakcaFeV6Z4_a--2nV3d7nOk-g@mail.gmail.com>
 <1997735.1n1TTR1eli@lapuntu> <53BB899A.40408@gmail.com>
 <CAOsGNSS1H87C666NJKNi7SQaftkxZkRhq6JOoS6NwyZsS5vaKg@mail.gmail.com>
 <CAOE4rSzEMCjRo57VQfP2gQ4xrCpKLxKd23XvH0YxH7ZE7jCnmQ@mail.gmail.com>
 <969fa7d4-d6b4-4d5c-bbbf-c5d7b6482746@email.android.com>
 <CAOE4rSziWQxm-3W6UP_hCAJN1u3stPbqn-nSXEu7oxcKYjVf_w@mail.gmail.com>
 <CAHWD2rL9gJv30n8AsjqF-ngbmu0F61jZRnCLTyX3k4OyoR8m2g@mail.gmail.com>
 <53BCD390.9040303@gmail.com>
 <CAHWD2rJt55_FiCNruwkoJ-_YKav9H+PSdhEjM8D7rTpzko4YDQ@mail.gmail.com>
Date: Thu, 10 Jul 2014 01:27:14 +0300
Message-ID: <CAOE4rSzQOdjTMMurtQAWv3+kx35KG2KDuzd2i53tKKZpdrp8GQ@mail.gmail.com>
Subject: Re: Tox.im
To: cypherpunks@cpunks.org
Content-Type: multipart/alternative; boundary=001a11c300a8cb771004fdca35fa
Cc: Bill Stewart <billstewart@pobox.com>
X-BeenThere: cypherpunks@cpunks.org
X-Mailman-Version: 2.1.16
Precedence: list
List-Id: The Cypherpunks Mailing List <cypherpunks.cpunks.org>
List-Unsubscribe: <https://cpunks.org/mailman/options/cypherpunks>,
 <mailto:cypherpunks-request@cpunks.org?subject=unsubscribe>
List-Archive: <http://cpunks.org/pipermail/cypherpunks/>
List-Post: <mailto:cypherpunks@cpunks.org>
List-Help: <mailto:cypherpunks-request@cpunks.org?subject=help>
List-Subscribe: <https://cpunks.org/mailman/listinfo/cypherpunks>,
 <mailto:cypherpunks-request@cpunks.org?subject=subscribe>
Errors-To: cypherpunks-bounces@cpunks.org
Sender: "cypherpunks" <cypherpunks-bounces@cpunks.org>
From: =?UTF-8?B?RMSBdmlzIE1vc8SBbnM=?= <davispuh@gmail.com>
X-Gspam-Loop: antiproton.jfet.org
Status: O
Content-Length: 33474
Lines: 605

--001a11c300a8cb771004fdca35fa
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

2014-07-08 23:31 GMT+03:00 Lodewijk andr=C3=A9 de la porte <l@odewijk.nl>:

> 2014-07-08 21:53 GMT+02:00 D=C4=81vis Mos=C4=81ns <davispuh@gmail.com>:
>
> Also what about NUL bytes? I bet most parsers are implemented in C/C++
>> using typical char * null-terminated string, how'll pass this JSON to
>> someone? because well NUL...
>
>
> At the parser level you would find a "b" character that's not between
> brackets, signalling a binary header is coming. A binary header is actual=
ly
> just the number of bytes that follow in binary format. The following byte=
s
> are then a binary file, to be assigned to a string as if it were a
> variable. We have a binarybuffer in javascript, that sort of thing. It
> would contain the NULL byte if you like it to.
>
> [...]
>
> I think it's much more serious that you have to serve the BJSON completel=
y
> as a binary file. It's not like you can dump it onto a webpage anymore. Y=
ou
> can't slip it into your normal HTTP text transfer bodies either, has to
> work with attachments. Attachments should be secure when facing malformed
> transfers* etc. Inconvenient, but not the end.
>
>
A lot of protocols are text based, often implemented using C strings and
that's what I mean, you can't embed a JSON with binary data containing NUL
there (because NUL will terminate that string), so you handle it like
typical binary file and then what's the point of JSON to use in first
place, because I don't see how it can be any better than any other proper
binary data. Such binary JSON gives only overhead but no advantages.


2014-07-09 7:25 GMT+03:00 Bill Stewart <billstewart@pobox.com>:

> I haven't used it in years, but I was always quite fond of XDR
> https://en.wikipedia.org/wiki/External_Data_Representation
> Sun's External Data Representation coding from the 80s, RFC-1014.
> Defines a bunch of variable types, and gives you tools for packing and
> unpacking them.
>
>
It's actually pretty good, but there are reasons why Protobuf was created
and used instead. The main benefit of Protobuf is that it's easily
extendable and can have optional fields. If you add or remove optional
fields to server all old clients will still work like nothing have changed.
But with XDR you can't do that unless you add another layer on top of it,
but that's more work comparing to just taking Protobuf and using it. Also
currently Protobuf is much more popular and have more libraries available
for dozens of langauges.


2014-07-09 8:30 GMT+03:00 "=C5=81ukasz \"Cyber Killer\" Korpalski" <
cyberkiller8@gmail.com>:

>
> It's really nice that so many of you got into the spirit and start
> thinking about how to change xmpp to make it something new, but what are
> you achieving here? It will end up being a new protocol, incompatible
> with existing xmpp, it will take a few years to finish the spec, then
> another 10+ years until any meaningful applications start using it (if
> at all)... So yeah, except being "coder porn" it does nothing to help
> the problem here and now.
>
>
The goal would be to create smaller overhead and thus be more performance
effective. Also it doesn't have to be incompatible. It could be
incorporated in XMPP so that new applications could use it but other's just
use same legacy XMPP and everything keeps working fine and people wouldn't
know what's happening under the hood, nor they would care. And I think it
would be trivial to convince people to use and enable this "Binary" XMPP
mode (if it's implemented in their client) which makes their chat client
app to use 100x times less bandwidth and 50x times less CPU time (spent in
parsing), thus your phone's battery would last longer. And yes XML overhead
is that big.


> A technically pretty proto won't help, today=E2=80=99s world has a huge p=
roblem
> with taking anything new. Better to stay with existing stuff, make it
> maybe less efficient because of it, but it will be here fast, when it's
> needed. Plus being less efficient is a no issue today, with fast
> machines (you can use compression on the fly, yes really :-P ), loads of
> storage, broadband connections (even the 3G data caps are getting larger
> and larger each year), etc. People are sending gigabytes of binary files
> in base64 each day in email messages, so why even care? ;-)
>
>
I guess you don't know that nothing is ever fast or good enough. People
will always want things faster. What about real-time video call in 4k @ 60
FPS ? It's unreal to imagine this in XMPP unless some really good binary
protocol is used so that it's not your software that creates a bottleneck,
but if it does then your software is bad and why would I use it over other
that can do it, the one that was designed for it, for example see Elemental
Demonstrates 4K HEVC Video at 60 fps in London
<http://www.streamingmediaglobal.com/Articles/Editorial/Featured-Articles/E=
lemental-Demonstrates-4K-HEVC-Video-at-60-fps-in-London-93707.aspx>

Anyway, I must admit that I haven't studied XMPP enough to know how good or
bad it is, but always should try to minimize any overhead, basically you
want to process as little as possible.

Here straight from wiki, weaknesses:

   - Does not support Quality of Service (QoS)
      - XMPP does not have the ability to set the timing flow of messages,
      preventing XMPP from becoming practical for many embedded distributed
      realtime, Machine-to-Machine, or IoT applications.
   - High overhead for embedded applications
      - As a text based protocol, XMPP has a relatively high computing and
      network overhead.
   - In-band binary data transfer is inefficient
      - Binary data must be first base64 encoded before it can be
      transmitted in-band. Therefore any significant amount of binary
data (e.g.,
      file transfers) is best transmitted out-of-band, using in-band
messages to
      coordinate. The best example of this is the Jingle
      <http://en.wikipedia.org/wiki/Jingle_%28protocol%29> XMPP Extension
      Protocol, XEP-0166 <http://xmpp.org/extensions/xep-0166.html>. This
      issue are being adressed by the experimental XEP-0322: Efficient XML
      Interchange (EXI) Format <http://xmpp.org/extensions/xep-0322.html>.


that sounds really really bad. But it's not all lost, Jingle
<http://xmpp.org/about-xmpp/technology-overview/jingle/> actually seems
good as it have option to switch to Real-time Transport Protocol (RTP)
<http://en.wikipedia.org/wiki/Real-time_Transport_Protocol> and then it's
just pure binary stream with minimal overhead. And looks like they are
aware of these issues as EXI is being developed, but still while it's a big
step forward, it will never beat pure binary protocol.

Also from wiki, this is good idea:

A perhaps more efficient transport for real-time messaging is WebSocket
<http://en.wikipedia.org/wiki/WebSocket>, a web technology providing for
bi-directional, full-duplex communications channels over a single TCP
connection. Experimental implementations of XMPP over WebSocket exist, and
a (now-expired) Internet-Draft documenting this approach was published at
the IETF but not yet standardized.


In my opinion the bottom line is - a small addition to existing xmpp has
> a far larger chance of being widely adopted (by applications and by the
> users) than a completely new protocol. And despite how awesome coder one
> might be - you won't be able to write all those implementations yourself
> or convince the masses to switch (again!).
>
>
Maybe yes, maybe no. I think if you've written specification in very clear
and understandable way and if you've reference implementation library which
everyone could just link against and if your protocol does it better than
current existing solutions then I don't see why it wouldn't get adapted.
Besides you don't need it implemented everywhere, you need it so that it's
in application you use and you could contribute there yourself.


2014-07-09 13:17 GMT+03:00 Lodewijk andr=C3=A9 de la porte <l@odewijk.nl>:

> [...]
>
> There is no masses using XMPP. Masses of coders, maybe, and they will use
> the best tool for the job.
>
> All the extensions have succeeded in making any XMPP app lacking in
> usability. I sure haven't found any nice XMPP clients, nice enough to
> compare with native clients.
>
 That's true indeed, currently there aren't any decent XMPP client (atleast
I'm not aware of any). I mean from user's usability point (UX/UI). There
are good either proprietary clients (eg. Skype) or good open source clients
(eq. Quassel) that doesn't support XMPP :D

In fact I'm willing to bet everyone in the western world uses FB, Google
> chat and MSN (slackers and slowpokes). They all have limited XMPP
> implementations, they native clients do more. And there's no good app for
> interacting with XMPP.
>
About which Western wold you're talking about? I don't know, but I would
assume that in Europe, Skype would be one of the most popular clients.
Atleast here MSN never was a thing and everyone have always been using
Skype and almost everyone still does. FB isn't really used that much (here
we've better alternative). And about Google Talk only some people are aware
that it even exists. I know that in Russia it's ICQ and in China it's QQ
that's dominating there. Anyway I think they don't implement XMPP because
it's too much work for too small benefit. Also then how they would compete
with others if they would be limited with XMPP if it doesn't do something
that they want to do. So own protocol might be safer bet for a lot of
companies. By the way Google Talk dropped XMPP support
<https://www.eff.org/deeplinks/2013/05/google-abandons-open-standards-insta=
nt-messaging>
.


I actually really hoped that Tox would succeed so that I could drop Skype
and convince others to do same :D But now I'm not so sure if there will be
some replacement in nearest future. Actually I think one of reason why Tox
created new protocol and didn't used XMPP is that generally XMPP consists
of client-server architecture and P2P support is only with extension which
isn't widely known nor implemented much. Also XMPP seems way too
complicated than it should be.

Pidgin really isn't good, it's just the only one out there. And it is still
> in the MSN era. I've switched to Office 2013 from Libre/OpenOffice and it
> really is in a different league all together. And it sucks that it is. Bu=
t
> what can we do?
>
I personally don't like Pidgin too. And about Office and LibreOffice they
both have their own advantages and disadvantages but I wouldn't say that
any of them would be significantly better or worse than other. Also it's
nothing to do with open souirce, it's just we've more users that want
everything to be perfect without any effort for free than go and help and
contribute to projects.


Ok, so anyway I've come to conclusion that I'm not sure anymore whether
it's better to try to fix XMPP or just create new much simpler and better
protocol. But in any case we really should summarize all our points about
what's bad in XMPP and send them to XMPP group and see if they're willing
to fix them and accept our proposals.

If we want to create a new protocol, then I've few ideas about it. Firstly
it's really a shame that a lot of things are getting reinvented over and
over again. So the main goal would be don't reinvent stuff but reuse as
much as possible from existing things. It would help a lot as there's
libraries for already everything and would just have to combine them. Next,
think about high-level differences between instant message, group message,
offline chat message, email, SMS, MMS, mailing list. What are differences?
Actually if you think about it, there are no differences at all, it's the
same message being delivered in various ways. But why single protocol
couldn't handle it all? In fact it could. We're already using browser for
all of that. It's just that there's no specification to unify it all in
single protocol. Imagine if we wouldn't need a separate application for
IRC, for email nor for other chats. It all could be handled by one general
protocol. And why stop here, actually calls, sound and video are also
exactly same. There's no really difference between text or sound/video,
it's just a data and it depends only how you interpret it. Also security,
there's only one option, just encrypt it all before sending. It's just so
simple.

This next generation protocol would be a superset of typical media
protocols and thus it wouldn't matter anymore what other people use. You
would just use some middle-ware protocol layer that would translate that
foreign protocol to this next-gen protocol and you simply use your favorite
client. From user's point of view it doesn't matter at all which protocol
is used under the hood.

So the main features and design goals of this protocol should be:

   - Support for peer-to-peer and client-server architectures over both TCP
   and UDP
   - Lightweight, minimal overhead, generally be just pass-thru
   - Efficient encoding, basically binary streams
   - Encryption by default with option for OTR
   - Data stream itself can contain anything: text, images, sound, video,
   animations, screen sharing (and even remote desktop control would be
   possible)
   - Dozens of events: joined, left, started typing and so on
   - One to one and one to many streams
   - maybe more things


So how that all would be possible? It's extremely simple. In client-server
architecture, open connection to server, establish TLS (for example) now
send this next-gen protocol header message (to specify what kind of data
you're sending) and then send your data, it could be for example a raw
Theora <http://www.theora.org/> stream (directly from your camera) or just
a text message. Then server just relays it to all parties.

I don't think it could be any simpler and nothing will beat this in terms
of performance. You've just some basic dependencies and what would be the
reason to complicate this? It's trivial to implement as there's already
libraries for those. In case of offline messages server would just store
them and in fact it could do same for sound and videos too. You know Vine,
Snapchat? what about YouTube, Soundcloud, basically it could support them
all. IMO this is millions worth idea :D


It's worth looking at WebSockets <https://www.websocket.org/>, WebRTC
<http://www.webrtc.org> and probably other standards.


I really don't understand why currently it all have been made so
complicated because it isn't.

--001a11c300a8cb771004fdca35fa
Content-Type: text/html; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

<div dir=3D"ltr"><div class=3D"gmail_extra"><div class=3D"gmail_quote">2014=
-07-08 23:31 GMT+03:00 Lodewijk andr=C3=A9 de la porte <span dir=3D"ltr">&l=
t;<a href=3D"mailto:l@odewijk.nl" target=3D"_blank">l@odewijk.nl</a>&gt;</s=
pan>:<br><blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px 0.8e=
x;border-left:1px solid rgb(204,204,204);padding-left:1ex">
<div dir=3D"ltr"><div class=3D"gmail_extra"><div class=3D"gmail_quote">2014=
-07-08 21:53 GMT+02:00 D=C4=81vis Mos=C4=81ns <span dir=3D"ltr">&lt;<a href=
=3D"mailto:davispuh@gmail.com" target=3D"_blank">davispuh@gmail.com</a>&gt;=
</span>:<div class=3D"">
<br><blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px 0.8ex;bor=
der-left:1px solid rgb(204,204,204);padding-left:1ex">

 Also what about NUL bytes? I bet most parsers are implemented in C/C++=20
using typical char * null-terminated string, how&#39;ll pass this JSON to=
=20
someone? because well NUL...</blockquote></div></div><br>At the parser=20
level you would find a &quot;b&quot; character that&#39;s not between brack=
ets,=20
signalling a binary header is coming. A binary header is actually just=20
the number of bytes that follow in binary format. The following bytes=20
are then a binary file, to be assigned to a string as if it were a=20
variable. We have a binarybuffer in javascript, that sort of thing. It=20
would contain the NULL byte if you like it to.</div>

<div class=3D"gmail_extra"><br>[...]</div><div class=3D"gmail_extra"><br>I=
=20
think it&#39;s much more serious that you have to serve the BJSON completel=
y
 as a binary file. It&#39;s not like you can dump it onto a webpage anymore=
.
 You can&#39;t slip it into your normal HTTP text transfer bodies either,=
=20
has to work with attachments. Attachments should be secure when facing=20
malformed transfers* etc. Inconvenient, but not the end.</div><br></div>
</blockquote></div><br></div><div class=3D"gmail_extra">A lot of protocols
 are text based, often implemented using C strings and that&#39;s what I=20
mean, you can&#39;t embed a JSON with binary data containing NUL there=20
(because NUL will terminate that string), so you handle it like typical=20
binary file and then what&#39;s the point of JSON to use in first place,=20
because I don&#39;t see how it can be any better than any other proper=20
binary data. Such binary JSON gives only overhead but no advantages.<br><br=
><br><div class=3D"gmail_quote">2014-07-09 7:25 GMT+03:00 Bill Stewart <spa=
n dir=3D"ltr">&lt;<a href=3D"mailto:billstewart@pobox.com" target=3D"_blank=
">billstewart@pobox.com</a>&gt;</span>:<br>
<blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px 0.8ex;border-=
left:1px solid rgb(204,204,204);padding-left:1ex">
I haven&#39;t used it in years, but I was always quite fond of XDR<br>
<a href=3D"https://en.wikipedia.org/wiki/External_Data_Representation" targ=
et=3D"_blank">https://en.wikipedia.org/wiki/External_Data_Representation</a=
><br>
Sun&#39;s External Data Representation coding from the 80s, RFC-1014.<br>
Defines a bunch of variable types, and gives you tools for packing and unpa=
cking them.<br>
<br>
</blockquote></div><br>It&#39;s actually pretty good, but there are reasons=
=20
why Protobuf was created and used instead. The main benefit of Protobuf=20
is that it&#39;s easily extendable and can have optional fields. If you add=
=20
or remove optional fields to server all old clients will still work like
 nothing have changed. But with XDR you can&#39;t do that unless you add=20
another layer on top of it, but that&#39;s more work comparing to just=20
taking Protobuf and using it. Also currently Protobuf is much more=20
popular and have more libraries available for dozens of langauges. <br><br>=
<div class=3D"gmail_extra"><br><div class=3D"gmail_quote">2014-07-09 8:30 G=
MT+03:00 &quot;=C5=81ukasz \&quot;Cyber Killer\&quot; Korpalski&quot; <span=
 dir=3D"ltr">&lt;<a href=3D"mailto:cyberkiller8@gmail.com" target=3D"_blank=
">cyberkiller8@gmail.com</a>&gt;</span>:<br>
<blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px 0.8ex;border-=
left:1px solid rgb(204,204,204);padding-left:1ex"><br>
It&#39;s really nice that so many of you got into the spirit and start<br>
thinking about how to change xmpp to make it something new, but what are<br=
>
you achieving here? It will end up being a new protocol, incompatible<br>
with existing xmpp, it will take a few years to finish the spec, then<br>
another 10+ years until any meaningful applications start using it (if<br>
at all)... So yeah, except being &quot;coder porn&quot; it does nothing to =
help<br>
the problem here and now.<br>
<br></blockquote><div><br></div><div>The goal would be to create smaller
 overhead and thus be more performance effective. Also it doesn&#39;t have=
=20
to be incompatible. It could be incorporated in XMPP so that new=20
applications could use it but other&#39;s just use same legacy XMPP and=20
everything keeps working fine and people wouldn&#39;t know what&#39;s happe=
ning=20
under the hood, nor they would care. And I think it would be trivial to=20
convince people to use and enable this &quot;Binary&quot; XMPP mode (if it&=
#39;s=20
implemented in their client) which makes their chat client app to use=20
100x times less bandwidth and 50x times less CPU time (spent in=20
parsing), thus your phone&#39;s battery would last longer. And yes XML=20
overhead is that big.<br></div><div><br></div><blockquote class=3D"gmail_qu=
ote" style=3D"margin:0px 0px 0px 0.8ex;border-left:1px solid rgb(204,204,20=
4);padding-left:1ex">
<br>
A technically pretty proto won&#39;t help, today=E2=80=99s world has a huge=
 problem<br>
with taking anything new. Better to stay with existing stuff, make it<br>
maybe less efficient because of it, but it will be here fast, when it&#39;s=
<br>
needed. Plus being less efficient is a no issue today, with fast<br>
machines (you can use compression on the fly, yes really :-P ), loads of<br=
>
storage, broadband connections (even the 3G data caps are getting larger<br=
>
and larger each year), etc. People are sending gigabytes of binary files<br=
>
in base64 each day in email messages, so why even care? ;-)<br>
<br></blockquote><div><br></div><div>I guess you don&#39;t know that nothin=
g
 is ever fast or good enough. People will always want things faster.=20
What about real-time video call in 4k @ 60 FPS ? It&#39;s unreal to imagine=
=20
this in XMPP unless some really good binary protocol is used so that=20
it&#39;s not your software that creates a bottleneck, but if it does then=
=20
your software is bad and why would I use it over other that can do it,=20
the one that was designed for it, for example see <a href=3D"http://www.str=
eamingmediaglobal.com/Articles/Editorial/Featured-Articles/Elemental-Demons=
trates-4K-HEVC-Video-at-60-fps-in-London-93707.aspx">Elemental Demonstrates=
 4K HEVC Video at 60 fps in London</a><br>
<br></div><div>Anyway,
 I must admit that I haven&#39;t studied XMPP enough to know how good or ba=
d
 it is, but always should try to minimize any overhead, basically you=20
want to process as little as possible. <br></div><div><br></div><div>Here s=
traight from wiki, weaknesses:<br>
<ul><li>Does not support Quality of Service (QoS)</li><ul><li>XMPP does not=
 have the ability to set the timing flow of messages,=20
preventing XMPP from becoming practical for many embedded distributed=20
realtime, Machine-to-Machine, or IoT applications.</li></ul><li>High overhe=
ad for embedded applications</li><ul><li>As a text based protocol, XMPP has=
 a relatively high computing and network overhead.</li></ul><li>In-band bin=
ary data transfer is inefficient</li>
<ul><li>Binary
 data must be first base64 encoded before it can be transmitted in-band.
 Therefore any significant amount of binary data (e.g., file transfers)=20
is best transmitted out-of-band, using in-band messages to coordinate.=20
The best example of this is the <a href=3D"http://en.wikipedia.org/wiki/Jin=
gle_%28protocol%29" title=3D"Jingle (protocol)">Jingle</a> XMPP Extension P=
rotocol, <a rel=3D"nofollow" class=3D"" href=3D"http://xmpp.org/extensions/=
xep-0166.html">XEP-0166</a>. This issue are being adressed by the experimen=
tal <a rel=3D"nofollow" class=3D"" href=3D"http://xmpp.org/extensions/xep-0=
322.html">XEP-0322: Efficient XML Interchange (EXI) Format</a>.</li>
</ul></ul><br>that sounds really really bad. But it&#39;s not all lost, <a =
href=3D"http://xmpp.org/about-xmpp/technology-overview/jingle/">Jingle</a> =
actually seems good as it have option to switch to <a href=3D"http://en.wik=
ipedia.org/wiki/Real-time_Transport_Protocol">Real-time Transport Protocol =
(RTP)</a>
 and then it&#39;s just pure binary stream with minimal overhead. And looks=
=20
like they are aware of these issues as EXI is being developed, but still
 while it&#39;s a big step forward, it will never beat pure binary protocol=
.<br><br></div><div>Also from wiki, this is good idea:<br></div><div><br>A =
perhaps more efficient transport for real-time messaging is <a href=3D"http=
://en.wikipedia.org/wiki/WebSocket" title=3D"WebSocket">WebSocket</a>, a we=
b technology providing for bi-directional, full-duplex communications chann=
els over a single TCP
 connection. Experimental implementations of XMPP over WebSocket exist,=20
and a (now-expired) Internet-Draft documenting this approach was=20
published at the IETF but not yet standardized.<br></div><div><br><br></div=
><blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px 0.8ex;border=
-left:1px solid rgb(204,204,204);padding-left:1ex">
In my opinion the bottom line is - a small addition to existing xmpp has<br=
>
a far larger chance of being widely adopted (by applications and by the<br>
users) than a completely new protocol. And despite how awesome coder one<br=
>
might be - you won&#39;t be able to write all those implementations yoursel=
f<br>
or convince the masses to switch (again!).<br>
<div class=3D""><div class=3D"h5"><br></div></div></blockquote><br></div>Ma=
ybe
 yes, maybe no. I think if you&#39;ve written specification in very clear=
=20
and understandable way and if you&#39;ve reference implementation library=
=20
which everyone could just link against and if your protocol does it=20
better than current existing solutions then I don&#39;t see why it wouldn&#=
39;t=20
get adapted. Besides you don&#39;t need it implemented everywhere, you need=
=20
it so that it&#39;s in application you use and you could contribute there=
=20
yourself.<br><br><br></div></div><div class=3D"gmail_extra"><div class=3D"g=
mail_quote">2014-07-09 13:17 GMT+03:00 Lodewijk andr=C3=A9 de la porte <spa=
n dir=3D"ltr">&lt;<a href=3D"mailto:l@odewijk.nl" target=3D"_blank">l@odewi=
jk.nl</a>&gt;</span>:<br>
<blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px 0.8ex;border-=
left:1px solid rgb(204,204,204);padding-left:1ex"><div class=3D""><p dir=3D=
"ltr">[...]<br></p></div><p dir=3D"ltr">There is no masses using XMPP. Mass=
es of coders, maybe, and they will use the best tool for the job.</p>

<p dir=3D"ltr">All the extensions have succeeded in making any XMPP app lac=
king in usability. I sure haven&#39;t found any nice XMPP clients, nice eno=
ugh to compare with native clients.</p></blockquote><div>=C2=A0That&#39;s t=
rue indeed, currently there aren&#39;t any decent XMPP client (atleast I&#3=
9;m not aware of any). I
 mean from user&#39;s usability point (UX/UI). There are good either=20
proprietary clients (eg. Skype) or good open source clients (eq. Quassel) t=
hat doesn&#39;t
 support XMPP :D<br><br></div><blockquote class=3D"gmail_quote" style=3D"ma=
rgin:0px 0px 0px 0.8ex;border-left:1px solid rgb(204,204,204);padding-left:=
1ex">
<p dir=3D"ltr">In fact I&#39;m willing to bet everyone in the western world=
 uses FB, Google chat and MSN (slackers and slowpokes). They all have limit=
ed XMPP implementations, they native clients do more. And there&#39;s no go=
od app for interacting with XMPP.</p>
</blockquote><div>About which Western wold you&#39;re talking about? I don&=
#39;t know, but I would assume that in Europe, Skype would be one of the mo=
st popular clients. Atleast here MSN never was a thing and everyone have al=
ways been using Skype and almost everyone still does. FB isn&#39;t really u=
sed that much (here we&#39;ve better alternative). And about Google Talk on=
ly some people are aware that it even exists. I know that in Russia it&#39;=
s ICQ and in China it&#39;s QQ that&#39;s dominating there. Anyway I think =
they don&#39;t implement XMPP because it&#39;s too much work for too small =
benefit. Also then how they would compete with others if they would be limi=
ted with XMPP if it doesn&#39;t do something that they want to do. So own p=
rotocol might be safer bet for a lot of companies. By the way <a href=3D"ht=
tps://www.eff.org/deeplinks/2013/05/google-abandons-open-standards-instant-=
messaging">Google Talk dropped XMPP support</a>.<br>
<br><br></div><div>I actually really hoped that Tox would succeed so that I=
 could drop Skype and convince others to do same :D But now I&#39;m not so =
sure if there will be some replacement in nearest future. Actually I think =
one of reason why Tox created new protocol and didn&#39;t used XMPP is that=
 generally XMPP consists of client-server architecture and P2P support is o=
nly with extension which isn&#39;t widely known nor implemented much. Also =
XMPP seems way too complicated than it should be.<br>
</div><div><br></div><blockquote class=3D"gmail_quote" style=3D"margin:0px =
0px 0px 0.8ex;border-left:1px solid rgb(204,204,204);padding-left:1ex">

<p dir=3D"ltr">Pidgin really isn&#39;t good, it&#39;s just the only one out=
 there. And it is still in the MSN era. I&#39;ve switched to Office 2013 fr=
om Libre/OpenOffice and it really is in a different league all together. An=
d it sucks that it is. But what can we do?</p>


</blockquote></div>I personally don&#39;t like Pidgin too. And about Office=
 and LibreOffice they both have their own advantages and disadvantages but =
I wouldn&#39;t say that any of them would be significantly better or worse =
than other. Also it&#39;s nothing to do with open souirce, it&#39;s just we=
&#39;ve more users that want everything to be perfect without any effort fo=
r free than go and help and contribute to projects.<br>
</div><div class=3D"gmail_extra"><br><br></div><div class=3D"gmail_extra">O=
k, so anyway I&#39;ve come to conclusion that I&#39;m not sure anymore whet=
her it&#39;s better to try to fix XMPP or just create new much simpler and =
better protocol. But in any case we really should summarize all our points =
about what&#39;s bad in XMPP and send them to XMPP group and see if they&#3=
9;re willing to fix them and accept our proposals.<br>
</div><div class=3D"gmail_extra"><br></div><div class=3D"gmail_extra">If we=
 want to create a new protocol, then I&#39;ve few ideas about it. Firstly i=
t&#39;s really a shame that a lot of things are getting reinvented over and=
 over again. So the main goal would be don&#39;t reinvent stuff but reuse a=
s much as possible from existing things. It would help a lot as there&#39;s=
 libraries for already everything and would just have to combine them. Next=
, think about high-level differences between instant message, group message=
, offline chat message, email, SMS, MMS, mailing list. What are differences=
? Actually if you think about it, there are no differences at all, it&#39;s=
 the same message being delivered in various ways. But why single protocol =
couldn&#39;t handle it all? In fact it could. We&#39;re already using brows=
er for all of that. It&#39;s just that there&#39;s no specification to unif=
y it all in single protocol. Imagine if we wouldn&#39;t need a separate app=
lication for IRC, for email nor for other chats. It all could be handled by=
 one general protocol. And why stop here, actually calls, sound and video a=
re also exactly same. There&#39;s no really difference between text or soun=
d/video, it&#39;s just a data and it depends only how you interpret it. Als=
o security, there&#39;s only one option, just encrypt it all before sending=
. It&#39;s just so simple.<br>
</div><div class=3D"gmail_extra"><br></div><div class=3D"gmail_extra">This =
next generation protocol would be a superset of typical media protocols and=
 thus it wouldn&#39;t matter anymore what other people use. You would just =
use some middle-ware protocol layer that would translate that foreign proto=
col to this next-gen protocol and you simply use your favorite client. From=
 user&#39;s point of view it doesn&#39;t matter at all which protocol is us=
ed under the hood.<br>
<br></div><div class=3D"gmail_extra">So the main features and design goals =
of this protocol should be:<br><ul><li>Support for peer-to-peer and client-=
server architectures over both TCP and UDP<br></li><li>Lightweight, minimal=
 overhead, generally be just pass-thru</li>
<li>Efficient encoding, basically binary streams</li><li>Encryption by defa=
ult with option for OTR</li><li>Data stream itself can contain anything: te=
xt, images, sound, video, animations, screen sharing (and even remote deskt=
op control would be possible)</li>
<li>Dozens of events: joined, left, started typing and so on<br></li><li>On=
e to one and one to many streams<br></li><li>maybe more things</li></ul><p>=
<br></p><p>So how that all would be possible? It&#39;s extremely simple. In=
 client-server architecture, open connection to server, establish TLS (for =
example) now send this next-gen protocol header message (to specify what ki=
nd of data you&#39;re sending) and then send your data, it could be for exa=
mple a raw <a href=3D"http://www.theora.org/">Theora</a> stream (directly f=
rom your camera) or just a text message. Then server just relays it to all =
parties.<br>
</p><p></p><p>I don&#39;t think it could be any simpler and nothing will be=
at this in terms of performance. You&#39;ve just some basic dependencies an=
d what would be the reason to complicate this? It&#39;s trivial to implemen=
t as there&#39;s already libraries for those. In case of offline messages s=
erver would just store them and in fact it could do same for sound and vide=
os too. You know Vine, Snapchat? what about YouTube, Soundcloud, basically =
it could support them all. IMO this is millions worth idea :D<br>
</p><p><br></p><p>It&#39;s worth looking at <a href=3D"https://www.websocke=
t.org/">WebSockets</a>, <a href=3D"http://www.webrtc.org">WebRTC</a> and pr=
obably other standards.</p><p><br></p><p>I really don&#39;t understand why =
currently it all have been made so complicated because it isn&#39;t.</p>
<p><br></p></div></div>

--001a11c300a8cb771004fdca35fa--

