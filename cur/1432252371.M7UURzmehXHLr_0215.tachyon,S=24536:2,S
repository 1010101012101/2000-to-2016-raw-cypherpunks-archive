From rswatjfet.org+caf_=rsw=jfet.org@gmail.com  Sat Jul 26 11:08:16 2014
Return-Path: <rswatjfet.org+caf_=rsw=jfet.org@gmail.com>
Received: from mail-pd0-f179.google.com (mail-pd0-f179.google.com [209.85.192.179])
	by antiproton.jfet.org (8.14.4/8.14.4/Debian-4.1) with ESMTP id s6QF8EX7003801
	(version=TLSv1/SSLv3 cipher=RC4-SHA bits=128 verify=NOT)
	for <rsw@jfet.org>; Sat, 26 Jul 2014 11:08:16 -0400
Authentication-Results: antiproton.jfet.org; dkim=fail
	reason="verification failed; unprotected key"
	header.d=gmail.com header.i=@gmail.com header.b=ZnaSW9q4;
	dkim-adsp=none (unprotected policy); dkim-atps=neutral
Received: by mail-pd0-f179.google.com with SMTP id ft15so7064294pdb.24
        for <rsw@jfet.org>; Sat, 26 Jul 2014 08:07:54 -0700 (PDT)
X-Received: by 10.66.252.134 with SMTP id zs6mr8641980pac.40.1406387273851;
        Sat, 26 Jul 2014 08:07:53 -0700 (PDT)
X-Forwarded-To: rsw@jfet.org
X-Forwarded-For: rswatjfet.org@gmail.com rsw@jfet.org
Delivered-To: rswatjfet.org@gmail.com
Received: by 10.70.3.197 with SMTP id e5csp109794pde;
        Sat, 26 Jul 2014 08:07:53 -0700 (PDT)
X-Received: by 10.68.68.162 with SMTP id x2mr26452415pbt.84.1406387272933;
        Sat, 26 Jul 2014 08:07:52 -0700 (PDT)
Received: from localhost (antiproton.jfet.org. [209.141.47.85])
        by mx.google.com with ESMTPS id z15si6251571pdj.50.2014.07.26.08.07.52
        for <rswATjfet.org@gmail.com>
        (version=TLSv1.2 cipher=RC4-SHA bits=128/128);
        Sat, 26 Jul 2014 08:07:52 -0700 (PDT)
Received-SPF: neutral (google.com: 209.141.47.85 is neither permitted nor denied by domain of rsw+cypherpunks-bounces=cpunks.org@gloop.phonon.net) client-ip=209.141.47.85;
Authentication-Results: mx.google.com;
       spf=neutral (google.com: 209.141.47.85 is neither permitted nor denied by domain of rsw+cypherpunks-bounces=cpunks.org@gloop.phonon.net) smtp.mail=rsw+cypherpunks-bounces=cpunks.org@gloop.phonon.net;
       dkim=fail header.i=@gmail.com
Received: from antiproton.jfet.org (localhost.localdomain [127.0.0.1])
	by antiproton.jfet.org (8.14.4/8.14.4/Debian-4.1) with ESMTP id s6QF4dn1003780;
	Sat, 26 Jul 2014 11:05:07 -0400
Received: from mail-oi0-f48.google.com (mail-oi0-f48.google.com
 [209.85.218.48])
 by antiproton.jfet.org (8.14.4/8.14.4/Debian-4.1) with ESMTP id s6QF4TmW003776
 (version=TLSv1/SSLv3 cipher=RC4-SHA bits=128 verify=NOT)
 for <cypherpunks@cpunks.org>; Sat, 26 Jul 2014 11:04:30 -0400
Received: by mail-oi0-f48.google.com with SMTP id h136so4397724oig.21
 for <cypherpunks@cpunks.org>; Sat, 26 Jul 2014 08:04:06 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=20120113;
 h=mime-version:sender:from:date:message-id:subject:to:content-type;
 bh=TJ5n8hnbPd7dT6ayVElyfuPTxKP70zNHv3vq4wXMgEc=;
 b=ZnaSW9q4VJ3ppgix3ym5BQ6rQFtoyeb5s+KcNqB6JARJEK1KUXe6oLj9DEqlzq/e0I
 yzM3fFPpAipKNB8XH2xdxup6eoLOJnz6ZiGXvwHHyBaf471LNmBMwHZmJ7PLcufDekie
 Sj8S0hALQJlAoJTtcyjnWGBAE4ENtEOOmuj5MPoYBQWSv8HIsrvkAjlT/b9RDRTE3GNT
 4aYR18fesny+817CLso7HMNOmBBa5acVqJ106zEM0hbNwgCbWXexeLm+fkWmrmuvWk3R
 M7NpRxtYiDkM6O4CVe4OmlS7gUcmFV4eYvEGykMdVqpGyCpgmkHT6KAR0rZ1fdmZ1JkW
 +iKQ==
X-Received: by 10.60.176.225 with SMTP id cl1mr32673826oec.36.1406387046084;
 Sat, 26 Jul 2014 08:04:06 -0700 (PDT)
MIME-Version: 1.0
Received: by 10.76.73.3 with HTTP; Sat, 26 Jul 2014 08:03:46 -0700 (PDT)
Date: Sat, 26 Jul 2014 17:03:46 +0200
X-Google-Sender-Auth: Di4jRsElz7Qp0Bgw6A_0p6eVnoU
Message-ID: <CAHWD2rKJxyh+Z6v3=UUCKFyTfkEQ8+9-YYjFFrvm9hOKXrhb+g@mail.gmail.com>
Subject: Browser JS (client side) crypto FUD
To: cryptography <cryptography@metzdowd.com>,
        "cypherpunks@cpunks.org" <cypherpunks@cpunks.org>,
        Crypto discussion list <cryptography@randombit.net>
Content-Type: multipart/alternative; boundary=047d7bd75e644c77c904ff1a00ae
X-BeenThere: cypherpunks@cpunks.org
X-Mailman-Version: 2.1.16
Precedence: list
List-Id: The Cypherpunks Mailing List <cypherpunks.cpunks.org>
List-Unsubscribe: <https://cpunks.org/mailman/options/cypherpunks>,
 <mailto:cypherpunks-request@cpunks.org?subject=unsubscribe>
List-Archive: <http://cpunks.org/pipermail/cypherpunks/>
List-Post: <mailto:cypherpunks@cpunks.org>
List-Help: <mailto:cypherpunks-request@cpunks.org?subject=help>
List-Subscribe: <https://cpunks.org/mailman/listinfo/cypherpunks>,
 <mailto:cypherpunks-request@cpunks.org?subject=subscribe>
Errors-To: cypherpunks-bounces@cpunks.org
Sender: "cypherpunks" <cypherpunks-bounces@cpunks.org>
From: =?UTF-8?Q?Lodewijk_andr=C3=A9_de_la_porte?= <l@odewijk.nl>
X-Gspam-Loop: antiproton.jfet.org
Status: O
Content-Length: 19950
Lines: 380

--047d7bd75e644c77c904ff1a00ae
Content-Type: text/plain; charset=UTF-8

http://matasano.com/articles/javascript-cryptography/

Is surprisingly often passed around as if it is the end-all to the idea of
client side JS crypto.

TL;DR: It's a fantastic load of horse crap, mixed in with some extremely
generalized cryptography issues that most people never thought about before
that do not harm JS crypto at all.

I'm not sure why the guy wrote it. Maybe he's NSA motivated? Maybe he's
worked a lot on secure systems and this just gives him the creeps? Maybe
he's the kind of guy that thinks <dash>JS</dash> dynamic scripted languages
are not a real languages?

Somebody, please, give me something to say against people that claim JS
client side crypto can just never work!

---------------------------------------------------------
Aside from that it's, well, fundamentally moronic to claim that something
is "harmful" when you actually means it does nothing, it's also just
(almost!) never true that no attacks are prevented.

But, let's go with the flow of the article. Rants won't really settle
arguments.

Two example usages are given.

The first is client-side hashing of a password, so that it's never sent in
the clear. This is so legitimate it nearly makes me drop my hat, but, the
author decides to use HMAC-SHA1 instead of SHA2 for reasons that are fully
beyond me. Perhaps just trying to make things less secure?

The second is using AES keys to client side encrypt. The author must've
thought he was being helpful when he imagined the scheme for this. Or maybe
he was drunk. "So you generate an AES key for each note, send it to the
user's browser to store locally, forget the key, and let the user wrap and
unwrap their data.". Somehow trusting the transport layer is all back in
vogue. The only key-generation problem in JS is entropy, which is a problem
everywhere tbh. If you really want to ensure entropy, send a random data
blob and XOR it with whatever client-side best-shot at randomness.
Whatever.

The author bluntheadedly claims "They will both fail to secure users". In
principle I agree, his methods sucked balls. He, however, blames it on JS.
Okay.. Let's go on.

REALLY? WHY?
> For several reasons, including the following:
> 1 Secure delivery of Javascript to browsers is a chicken-egg problem.
> 2 Browser Javascript is hostile to cryptography.
> 3 The "view-source" transparency of Javascript is illusory.

Until those problems are fixed, Javascript isn't a serious crypto research
> environment, and suffers for it.

(points numbered for pointwise addressing)

1 - Yeah. Duh. What do you think of delivering anything client side?
There's the whole SSL infrastructure, if that doesn't cut it for you, well,
welcome to the Internet. (I suggest the next article is about how the
Internet is fundamentally flawed.) I would suggest, however, that once your
delivery pathway is exploited you're fundamentally screwed in every way.
You can't communicate anything, you can't authenticate anyone, you really
can't *do* anything! So let's leave out the "Javascript" part of this
point, and just do whatever we're already doing to alleviate this issue.

2 - This is a conclusion without any basis so far (aside from being..
meaningless to a computer scientist. Hostile?)

3 - Then just look at what data was transferred. Does every crypto
application require checkable source? Is any SSL implementation "considered
harmful" because nobody is able to flawlessly read the code, no compilers
are trusted, etc?

Okay so that chapter meant absolutely nothing. The author goes on to try to
defend his brabble:

"WHAT'S THE "CHICKEN-EGG PROBLEM" WITH DELIVERING JAVASCRIPT CRYPTOGRAPHY?

If you don't trust the network to deliver a password, or, worse, don't
trust the server not to keep user secrets, you can't trust them to deliver
security code. The same attacker who was sniffing passwords or reading
diaries before you introduce crypto is simply hijacking crypto code after
you do."

A fair point against a single thread model. Interestingly the last line
does absolutely not have to hold, sniffing (after the fact) and on-the-fly
rewriting are worlds apart. Take Tempest of Xkeyscore, for example, they
can't do rewrites. They need specialized programs for that. (Conclusion:
nope, nothing to see here)

The next chapter tries to justify the fallacies made earlier on. Equating a
rewrite to a read, ad-homineming the JS crypto "industry" (and failing to
distinguish operational security from actual security), and lastly claiming
that misplaced trust is bad (which is obvious and unrelated).

The next chapter claims SSL is safe, and "real" crypto unlike JS crypto.
Then firmly cements his baseless ridicule by claiming that if you use
non-JS crypto to make JS crypto work, then obviously there's no point.

The next chapter "WHAT'S HARD ABOUT DEPLOYING JAVASCRIPT CRYPTO CODE OVER
SSL/TLS?" claims all the page has to be SSL/TLS and that makes it hard.
It's not hard and you should already be doing it to have /*any*/ security.
Not to mention it's not true, only that interpreted as page contents has to
be SSL'ed (eg, images don't need to be transported over SSL).

So, point 1 has no merit against JS whatsoever. There's also a lot of
FUD-like text that denies reality. Especially the assumption that SSL and
desktop programs are somehow more secure.

So point 2.

(letterized for pointwise addressing)
"HOW ARE BROWSERS HOSTILE TO CRYPTOGRAPHY?
In a dispriting variety of ways, among them:

a - The prevalence of content-controlled code.
b - The malleability of the Javascript runtime.
c - The lack of systems programming primitives needed to implement crypto.
d - The crushing weight of the installed base of users.

Each of these issues creates security gaps that are fatal to secure crypto.
Attackers will exploit them to defeat systems that should otherwise be
secure. There may be no way to address them without fixing browsers."

a, c, d are, at first sight, all rubbish. b is a very genuine point
however. With prototyping and the like it can be VERY hard to see what's
going on. It's an often mentioned thing about JS that it's too powerful in
some ways, and it can be true. The same goes for C and memory control.

Next chapter confirms that a is rubbish.

Chapter after that explains some basic Comp Sci about when you can trust
something (and discredits something that can help in a lot of cases, any if
you do it correctly (which is too hard))

Chapter after that rehashes the idea that you can't trust the environment
unless you trust the whole environment, which is also the same everywhere.
(I also refer to trusting the compiler)

Next chapter is titled "WELL THEN, COULDN'T I WRITE A SIMPLE BROWSER
EXTENSION THAT WOULD ALLOW JAVASCRIPT TO VERIFY ITSELF?". And guess what,
the author agrees. You can indeed do this. If you're just doing it for
yourself or a single kind of crypto you could also make a plugin for that.
Which is what the WhatWG is doing with the HTML5 crypto extension. Then
claims crypto is to PGP as programming languages are to Lisp, which is
rubbish.

The author then goes on to actually talk about random generators. Which are
not always required, but who cares, right? Then Secure erase, which is only
important if you expect the client device to be exploited. Then ?timing
attacks? which is even more specific and can be alleviated easily enough.

Then tries to generalize his claim to remove JS specifically from the
equation, removing is last viable (but not definitive) arguments.

Some hating on key management, which is justified but again bullocks wrt
the main argument. (not to mention it's a problem everywhere, and it can be
solved like everywhere)

Some hate on people running old browsers, which has actually been solved by
background-auto-updating by now. (huzzah for all the added insecurity there)

Then something about graceful degrading. Which is fair except for him not
sufficiently providing any reason JS crypto never works. (and not
relevant). He apparently meant this with d. Depends greatly on the
deployment situation, but in general it's FUD.


"AND WHEN YOU SAID "VIEW-SOURCE TRANSPARENCY WAS ILLUSORY"?

We meant that you can't just look at a Javascript file and know that it's
secure, even in the vanishingly unlikely event that you were a skilled
cryptographer, because of all the reasons we just cited."

Yeah. Welcome to programming. There's absolutely no truth to this claim
btw. Vagely referring to a large body of rubbish is not an argument.

The rest does not even try to take a direct shot anymore. Something about
how users that use 100 programs are more likely to find an insecure one
than people that use only 2 or 3.

He's the kind of guy that claims cracking and rewriting SSL connections is
easy, whereas using AES for a secure "cryptosystem" is hard. I don't know
what's up with this guy.

--047d7bd75e644c77c904ff1a00ae
Content-Type: text/html; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

<div dir=3D"ltr"><a href=3D"http://matasano.com/articles/javascript-cryptog=
raphy/">http://matasano.com/articles/javascript-cryptography/</a><br><div><=
br></div><div>Is surprisingly often passed around as if it is the end-all t=
o the idea of client side JS crypto.</div>

<div><br></div><div>TL;DR: It&#39;s a fantastic load of horse crap, mixed i=
n with some extremely generalized cryptography issues that most people neve=
r thought about before that do not harm JS crypto at all.</div><div><br>

</div><div>I&#39;m not sure why the guy wrote it. Maybe he&#39;s NSA motiva=
ted? Maybe he&#39;s worked a lot on secure systems and this just gives him =
the creeps? Maybe he&#39;s the kind of guy that thinks &lt;dash&gt;JS&lt;/d=
ash&gt; dynamic scripted languages are not a real languages?</div>

<div><br></div><div>Somebody, please, give me something to say against peop=
le that claim JS client side crypto can just never work!</div><div><br></di=
v><div>---------------------------------------------------------</div>
<div>
Aside from that it&#39;s, well, fundamentally moronic to claim that somethi=
ng is &quot;harmful&quot; when you actually means it does nothing, it&#39;s=
 also just (almost!) never true that no attacks are prevented.</div><div>

<br></div><div>But, let&#39;s go with the flow of the article. Rants won&#3=
9;t really settle arguments.</div><div><br></div><div>Two example usages ar=
e given.</div><div><br></div><div>The first is client-side hashing of a pas=
sword, so that it&#39;s never sent in the clear. This is so legitimate it n=
early makes me drop my hat, but, the author decides to use HMAC-SHA1 instea=
d of SHA2 for reasons that are fully beyond me. Perhaps just trying to make=
 things less secure?</div>

<div><br></div><div>The second is using AES keys to client side encrypt. Th=
e author must&#39;ve thought he was being helpful when he imagined the sche=
me for this. Or maybe he was drunk. &quot;So you generate an AES key for ea=
ch note, send it to the user&#39;s browser to store locally, forget the key=
, and let the user wrap and unwrap their data.&quot;. Somehow trusting the =
transport layer is all back in vogue. The only key-generation problem in JS=
 is entropy, which is a problem everywhere tbh. If you really want to ensur=
e entropy, send a random data blob and XOR it with whatever client-side bes=
t-shot at randomness. Whatever.=C2=A0</div>

<div><br></div><div>The author bluntheadedly claims &quot;They will both fa=
il to secure users&quot;. In principle I agree, his methods sucked balls. H=
e, however, blames it on JS. Okay.. Let&#39;s go on.</div><div><br></div>

<blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px 0.8ex;border-=
left-width:1px;border-left-color:rgb(204,204,204);border-left-style:solid;p=
adding-left:1ex">REALLY? WHY?<br>For several reasons, including the followi=
ng:<br>

1 Secure delivery of Javascript to browsers is a chicken-egg problem.<br>2 =
Browser Javascript is hostile to cryptography.<br>3 The &quot;view-source&q=
uot; transparency of Javascript is illusory.=C2=A0</blockquote><blockquote =
class=3D"gmail_quote" style=3D"margin:0px 0px 0px 0.8ex;border-left-width:1=
px;border-left-color:rgb(204,204,204);border-left-style:solid;padding-left:=
1ex">

Until those problems are fixed, Javascript isn&#39;t a serious crypto resea=
rch environment, and suffers for it.</blockquote><div>(points numbered for =
pointwise addressing)</div><div><br></div><div>1 - Yeah. Duh. What do you t=
hink of delivering anything client side? There&#39;s the whole SSL infrastr=
ucture, if that doesn&#39;t cut it for you, well, welcome to the Internet. =
(I suggest the next article is about how the Internet is fundamentally flaw=
ed.) I would suggest, however, that once your delivery pathway is exploited=
 you&#39;re fundamentally screwed in every way. You can&#39;t communicate a=
nything, you can&#39;t authenticate anyone, you really can&#39;t <i><b>do</=
b></i> anything! So let&#39;s leave out the &quot;Javascript&quot; part of =
this point, and just do whatever we&#39;re already doing to alleviate this =
issue.</div>

<div><br></div><div>2 - This is a conclusion without any basis so far (asid=
e from being.. meaningless to a computer scientist. Hostile?)</div><div><br=
></div><div>3 - Then just look at what data was transferred. Does every cry=
pto application require checkable source? Is any SSL implementation &quot;c=
onsidered harmful&quot; because nobody is able to flawlessly read the code,=
 no compilers are trusted, etc?<br>

<br>Okay so that chapter meant absolutely nothing. The author goes on to tr=
y to defend his brabble:</div><br>&quot;WHAT&#39;S THE &quot;CHICKEN-EGG PR=
OBLEM&quot; WITH DELIVERING JAVASCRIPT CRYPTOGRAPHY?<br><br>If you don&#39;=
t trust the network to deliver a password, or, worse, don&#39;t trust the s=
erver not to keep user secrets, you can&#39;t trust them to deliver securit=
y code. The same attacker who was sniffing passwords or reading diaries bef=
ore you introduce crypto is simply hijacking crypto code after you do.&quot=
;<div>

=C2=A0</div><div>A fair point against a single thread model. Interestingly =
the last line does absolutely not have to hold, sniffing (after the fact) a=
nd on-the-fly rewriting are worlds apart. Take Tempest of Xkeyscore, for ex=
ample, they can&#39;t do rewrites. They need specialized programs for that.=
 (Conclusion: nope, nothing to see here)</div>

<div><br></div><div>The next chapter tries to justify the fallacies made ea=
rlier on. Equating a rewrite to a read, ad-homineming the JS crypto &quot;i=
ndustry&quot; (and failing to distinguish operational security from actual =
security), and lastly claiming that misplaced trust is bad (which is obviou=
s and unrelated).</div>

<div><br></div><div>The next chapter claims SSL is safe, and &quot;real&quo=
t; crypto unlike JS crypto. Then firmly cements his baseless ridicule by cl=
aiming that if you use non-JS crypto to make JS crypto work, then obviously=
 there&#39;s no point.</div>

<div><br></div><div>The next chapter &quot;WHAT&#39;S HARD ABOUT DEPLOYING =
JAVASCRIPT CRYPTO CODE OVER SSL/TLS?&quot; claims all the page has to be SS=
L/TLS and that makes it hard. It&#39;s not hard and you should already be d=
oing it to have /<i style=3D"font-weight:bold">any</i>/ security. Not to me=
ntion it&#39;s not true, only that interpreted as page contents has to be S=
SL&#39;ed (eg, images don&#39;t need to be transported over SSL).</div>

<div><br></div><div>So, point 1 has no merit against JS whatsoever. There&#=
39;s also a lot of FUD-like text that denies reality. Especially the assump=
tion that SSL and desktop programs are somehow more secure.</div><div>
<br>
</div><div>So point 2.</div><div><br>(letterized for pointwise addressing)<=
/div><div>&quot;HOW ARE BROWSERS HOSTILE TO CRYPTOGRAPHY?<br>In a dispritin=
g variety of ways, among them:<br><br>a - The prevalence of content-control=
led code.<br>

b - The malleability of the Javascript runtime.<br>c - The lack of systems =
programming primitives needed to implement crypto.<br>d -=C2=A0The crushing=
 weight of the installed base of users.</div><div><br>Each of these issues =
creates security gaps that are fatal to secure crypto. Attackers will explo=
it them to defeat systems that should otherwise be secure. There may be no =
way to address them without fixing browsers.&quot;</div>

<div><br></div><div>a, c, d are, at first sight, all rubbish. b is a very g=
enuine point however. With prototyping and the like it can be VERY hard to =
see what&#39;s going on. It&#39;s an often mentioned thing about JS that it=
&#39;s too powerful in some ways, and it can be true. The same goes for C a=
nd memory control.</div>

<div><br></div><div>Next chapter confirms that a is rubbish.</div><div><br>=
</div><div>Chapter after that explains some basic Comp Sci about when you c=
an trust something (and discredits something that can help in a lot of case=
s, any if you do it correctly (which is too hard))</div>

<div><br></div><div>Chapter after that rehashes the idea that you can&#39;t=
 trust the environment unless you trust the whole environment, which is als=
o the same everywhere. (I also refer to trusting the compiler)</div><div>

<br></div><div>Next chapter is titled &quot;WELL THEN, COULDN&#39;T I WRITE=
 A SIMPLE BROWSER EXTENSION THAT WOULD ALLOW JAVASCRIPT TO VERIFY ITSELF?&q=
uot;. And guess what, the author agrees. You can indeed do this. If you&#39=
;re just doing it for yourself or a single kind of crypto you could also ma=
ke a plugin for that. Which is what the WhatWG is doing with the HTML5 cryp=
to extension. Then claims crypto is to PGP as programming languages are to =
Lisp, which is rubbish.</div>

<div><br></div><div>The author then goes on to actually talk about random g=
enerators. Which are not always required, but who cares, right? Then Secure=
 erase, which is only important if you expect the client device to be explo=
ited. Then ?timing attacks? which is even more specific and can be alleviat=
ed easily enough.=C2=A0</div>

<div><br></div><div>Then tries to generalize his claim to remove JS specifi=
cally from the equation, removing is last viable (but not definitive) argum=
ents.</div><div><br></div><div>Some hating on key management, which is just=
ified but again bullocks wrt the main argument. (not to mention it&#39;s a =
problem everywhere, and it can be solved like everywhere)</div>

<div><br></div><div>Some hate on people running old browsers, which has act=
ually been solved by background-auto-updating by now. (huzzah for all the a=
dded insecurity there)</div><div><br></div><div>Then something about gracef=
ul degrading. Which is fair except for him not sufficiently providing any r=
eason JS crypto never works. (and not relevant). He apparently meant this w=
ith d. Depends greatly on the deployment situation, but in general it&#39;s=
 FUD.</div>

<div><br></div><br>&quot;AND WHEN YOU SAID &quot;VIEW-SOURCE TRANSPARENCY W=
AS ILLUSORY&quot;?<br><br>We meant that you can&#39;t just look at a Javasc=
ript file and know that it&#39;s secure, even in the vanishingly unlikely e=
vent that you were a skilled cryptographer, because of all the reasons we j=
ust cited.&quot;<div>

<br></div><div>Yeah. Welcome to programming. There&#39;s absolutely no trut=
h to this claim btw. Vagely referring to a large body of rubbish is not an =
argument.</div><div><br></div><div>The rest does not even try to take a dir=
ect shot anymore. Something about how users that use 100 programs are more =
likely to find an insecure one than people that use only 2 or 3.</div>

<div><br></div><div>He&#39;s the kind of guy that claims cracking and rewri=
ting SSL connections is easy, whereas using AES for a secure &quot;cryptosy=
stem&quot; is hard. I don&#39;t know what&#39;s up with this guy.</div>

</div>

--047d7bd75e644c77c904ff1a00ae--

